/**
 * Custom Query Execution Endpoint
 *
 * Executes SQL queries generated by the form-based query builder.
 * Injects school security filters automatically based on user permissions.
 */

import { NextResponse } from 'next/server';
import { auth, SessionUser } from '@/auth';
import { runQuery } from '@/lib/aeries';
import { checkRateLimit, getRateLimitIdentifier } from '@/lib/rateLimit';

// School code to name mapping for logging
const SCHOOL_NAMES: Record<string, string> = {
  '2': 'Garfield Elementary',
  '3': 'Jefferson Elementary',
  '4': 'Madison Elementary',
  '5': 'McKinley Elementary',
  '6': 'Monroe Elementary',
  '7': 'Roosevelt Elementary',
  '8': 'Washington Elementary',
  '9': 'Halkin Elementary',
  '11': 'Bancroft Middle School',
  '12': 'Muir Middle School',
  '15': 'Lincoln High School',
  '16': 'San Leandro High School',
  '60': 'SLVA Elementary',
  '61': 'SLVA Middle',
  '62': 'SLVA High',
};

/**
 * Inject school security filter into SQL query
 */
function injectSchoolFilter(sql: string, schoolIds: string[]): string {
  if (schoolIds.length === 0) {
    return sql;
  }

  const schoolList = schoolIds.join(', ');
  const filterCondition = `d.school_id IN (${schoolList})`;

  // Check if query already has a WHERE clause
  const whereMatch = sql.match(/\bWHERE\b/i);

  if (whereMatch) {
    // Insert school filter after WHERE
    const whereIndex = sql.search(/\bWHERE\b/i);
    const beforeWhere = sql.substring(0, whereIndex + 5);
    const afterWhere = sql.substring(whereIndex + 5);
    return `${beforeWhere} ${filterCondition}\n  AND${afterWhere}`;
  } else {
    // No WHERE clause, add one before ORDER BY
    const orderMatch = sql.match(/\bORDER\s+BY\b/i);
    if (orderMatch) {
      const orderIndex = sql.search(/\bORDER\s+BY\b/i);
      const beforeOrder = sql.substring(0, orderIndex);
      const orderClause = sql.substring(orderIndex);
      return `${beforeOrder}\nWHERE ${filterCondition}\n${orderClause}`;
    } else {
      // No ORDER BY either, just append WHERE
      return `${sql}\nWHERE ${filterCondition}`;
    }
  }
}

/**
 * Validate SQL for basic safety
 */
function validateSql(sql: string): { valid: boolean; error?: string } {
  const upperSql = sql.toUpperCase();

  // Check for dangerous keywords
  const dangerousKeywords = ['DROP', 'DELETE', 'UPDATE', 'INSERT', 'ALTER', 'CREATE', 'TRUNCATE', 'EXEC', 'EXECUTE'];
  for (const keyword of dangerousKeywords) {
    // Use word boundary check
    const regex = new RegExp(`\\b${keyword}\\b`, 'i');
    if (regex.test(sql)) {
      return { valid: false, error: `Query contains forbidden keyword: ${keyword}` };
    }
  }

  // Must start with SELECT
  if (!upperSql.trim().startsWith('SELECT')) {
    return { valid: false, error: 'Query must start with SELECT' };
  }

  // Must reference llm_* views
  if (!sql.includes('llm_')) {
    return { valid: false, error: 'Query must use llm_* views' };
  }

  return { valid: true };
}

export async function POST(request: Request) {
  const startTime = Date.now();

  try {
    // Check authentication
    const session = await auth();
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const user = session.user as unknown as SessionUser;

    // Rate limiting: 20 requests per 30 seconds per user
    const identifier = await getRateLimitIdentifier(request, user.id);
    const rateLimit = checkRateLimit(identifier, {
      maxRequests: 20,
      windowSeconds: 30,
    });

    if (!rateLimit.success) {
      return NextResponse.json(
        {
          error: 'Too many requests',
          message: `Rate limit exceeded. Try again after ${new Date(rateLimit.reset).toLocaleTimeString()}`,
        },
        {
          status: 429,
          headers: {
            'X-RateLimit-Limit': rateLimit.limit.toString(),
            'X-RateLimit-Remaining': rateLimit.remaining.toString(),
            'X-RateLimit-Reset': rateLimit.reset.toString(),
            'Retry-After': Math.ceil((rateLimit.reset - Date.now()) / 1000).toString(),
          },
        }
      );
    }

    const activeSchool = user.activeSchool ?? -1;
    const allowedSchools = user.schools || [];

    // Deny access if no school set
    if (activeSchool === -1) {
      return NextResponse.json({
        error: 'No school access. Please select a school from the school picker.'
      }, { status: 403 });
    }

    // Get request body
    const body = await request.json();
    const { sql, schoolFilter } = body;

    if (!sql?.trim()) {
      return NextResponse.json({ error: 'SQL query is required' }, { status: 400 });
    }

    // Validate SQL
    const validation = validateSql(sql);
    if (!validation.valid) {
      return NextResponse.json({
        success: false,
        error: validation.error
      }, { status: 400 });
    }

    // Determine school filter
    let schoolsToFilter: string[];

    if (activeSchool === 0) {
      // District-wide mode
      if (schoolFilter && schoolFilter.length > 0) {
        // User selected specific schools, but verify they have access
        schoolsToFilter = schoolFilter.filter((s: string) =>
          allowedSchools.length === 0 || allowedSchools.includes(s)
        );
      } else {
        // No specific selection, use all allowed schools
        schoolsToFilter = allowedSchools.length > 0 ? allowedSchools : [];
      }
    } else {
      // Single school mode
      schoolsToFilter = [activeSchool.toString()];
    }

    console.log(`[Custom Query] User: ${user.email}`);
    console.log(`[Custom Query] Schools: ${schoolsToFilter.length > 0 ? schoolsToFilter.join(', ') : 'all'}`);

    // Inject school security filter
    const securedSql = injectSchoolFilter(sql, schoolsToFilter);

    console.log('[Custom Query] Executing:', securedSql);

    // Execute query
    const queryResult = await runQuery(securedSql);
    const data = queryResult as any[] | null;
    const rowCount = data?.length || 0;

    const duration = Date.now() - startTime;

    console.log(`[Custom Query] Returned ${rowCount} rows in ${duration}ms`);

    return NextResponse.json({
      success: true,
      data: data,
      rowCount: rowCount,
      executedSql: securedSql,
      metadata: {
        durationMs: duration,
        schoolScope: activeSchool === 0
          ? (schoolsToFilter.length > 0
            ? `${schoolsToFilter.length} schools`
            : 'All schools')
          : SCHOOL_NAMES[activeSchool.toString()] || `School ${activeSchool}`,
      }
    });

  } catch (error) {
    const duration = Date.now() - startTime;
    console.error('[Custom Query] Error:', error);

    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Query execution failed',
      durationMs: duration
    }, { status: 500 });
  }
}
