generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id            String          @id @default(cuid())
  name          String
  email         String          @unique
  image         String?
  admin         Boolean         @default(false)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  lastLogin     DateTime?
  queryEdit     Boolean         @default(false)
  primaryRole   ROLE            @default(USER)
  emailVerified DateTime?
  primarySchool Int?
  psl           Int?            @unique
  activeSchool  Int             @default(0)
  activeDbYear  Int             @default(25) // Aeries DB year (e.g., 25 = DST25000SLUSD for 2024-25)
  manualSchool  Int?
  emulatingId   String?         // ID of user being emulated (null = not emulating)
  // Manual overrides for access control
  blockedSchools  String?       @db.Text // Comma-separated school codes to block (overrides Aeries)
  addedSchools    String?       @db.Text // Comma-separated school codes to add (supplements Aeries)
  blockedRoles    String?       @db.Text // Comma-separated roles to block
  addedRoles      String?       @db.Text // Comma-separated roles to add
  favorites     Query[]         @relation("id")
  Account       Account?
  Authenticator Authenticator[]
  Session       Session[]
  UserClass     UserClass[]
  UserRole      UserRole[]
  UserSchool    UserSchool[]
  userRole      Role[]          @relation("UserRole")
  school        SchoolInfo[]    @relation("UserSchool")

  @@index([emulatingId]) // For checking who is being emulated
  @@index([admin]) // For filtering admin users
  @@index([primaryRole]) // For role-based access control
}

model Account {
  id                       String   @id @default(cuid())
  userId                   String   @unique
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String?  @db.Text
  access_token             String?  @db.Text
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String?  @db.Text
  session_state            String?
  createdAt                DateTime @default(now())
  refresh_token_expires_in Int?
  updatedAt                DateTime @updatedAt
  user                     User     @relation(fields: [userId], references: [id])

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([expires]) // For cleaning up expired sessions
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
}

model Authenticator {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?
  user                 User    @relation(fields: [userId], references: [id])

  @@id([userId, credentialID])
}

model Role {
  id            String          @id @default(cuid())
  role          ROLE
  queryId       String?
  Query         Query?          @relation(fields: [queryId], references: [id])
  UserRole      UserRole[]
  QueryCategory QueryCategory[] @relation("QueryCategoryToRole")
  users         User[]          @relation("UserRole")

  @@index([queryId], map: "Role_queryId_fkey")
  @@index([role]) // For looking up roles by ROLE enum value
}

model SchoolInfo {
  id         String       @id @default(cuid())
  sc         String       @unique
  name       String
  logo       String?
  UserSchool UserSchool[]
  users      User[]       @relation("UserSchool")
}

model UserSchool {
  userId   String
  schoolSc String
  school   SchoolInfo @relation(fields: [schoolSc], references: [id])
  user     User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, schoolSc])
  @@index([schoolSc], map: "UserSchool_schoolSc_fkey")
}

model UserRole {
  userId String
  roleId String
  role   Role   @relation(fields: [roleId], references: [id])
  user   User   @relation(fields: [userId], references: [id])

  @@id([userId, roleId])
  @@index([roleId], map: "UserRole_roleId_fkey")
}

model UserClass {
  classId String
  userId  String
  class   Class  @relation(fields: [classId], references: [id], onDelete: Cascade)
  user    User   @relation(fields: [userId], references: [id])

  @@id([userId, classId])
  @@index([classId], map: "UserClass_classId_fkey")
}

model Class {
  id             String      @id @default(cuid())
  sc             Int
  tn             Int
  psl            Int
  email          String?
  StaffID2       Int?
  StaffID3       Int?
  activeOverride Boolean     @default(false)
  UserClass      UserClass[]

  @@index([email]) // For looking up classes by teacher email
  @@index([sc, tn]) // For composite lookups by school and teacher number
}

model Query {
  id             String         @id @default(cuid())
  query          String         @db.Text
  name           String
  label          String         @unique
  createdBy      String
  description    String
  publicQuery    Boolean        @default(false)
  categoryId     String?
  hiddenCols     String         @default("")
  chart          Boolean        @default(false)
  chartXKey      String?
  chartYKey      String?
  chartTypeKey   String? 
  chartStackKey  Boolean        @default(false)
  widgetLinkOverride  String?
  chartSeriesOverride String?      
  Chart          Chart[]
  category       QueryCategory? @relation(fields: [categoryId], references: [id])
  roles          Role[]

  @@index([categoryId], map: "Query_categoryId_fkey")
  @@index([publicQuery]) // For filtering public/private queries
  @@index([chart]) // For filtering chart queries
  User User[] @relation("id")
}

model QueryCategory {
  id      String  @id @default(cuid())
  label   String  @unique
  value   String  @unique
  sort    Int     @default(0)
  queries Query[]
  roles   Role[]  @relation("QueryCategoryToRole")
}

model Chart {
  id          String    @id @default(cuid())
  type        CHARTTYPE
  title       String
  chartConfig Json
  queryId     String
  query       Query     @relation(fields: [queryId], references: [id])

  @@index([queryId], map: "Chart_queryId_fkey")
}

// Grade Distribution
// Add this to your schema.prisma file

model GradeDistribution {
  id            String   @id @default(cuid())
  source        String?
  schoolYear    String   @db.VarChar(50)
  sc            Int      // School Code
  studentId     String   // Student ID
  studentNumber String   // Student Number (SN)
  grade         String?  // GR
  gender       String?  // GE
  period        String?  // PD
  departmentCode String? // DEPT_CODE
  course        String? // CO (Not used)
  divisionCode  String?  // DC
  courseNumber  String?  // CN
  courseTitle   String?  // CO
  teacherNumber String     // TN
  section       String?  // SE
  term          String
  mark          String
  teacherName   String   // TE
  specialEd     String?
  ell           String?  // English Language Learner
  ard           String?  // American Race/Ethnicity
  dli           String?  // Dual Language Student
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Indexes for faster queries
  @@index([sc, teacherNumber, term, mark])
  @@index([schoolYear, sc])
  @@index([studentId, term])
  // Smaller composite indexes for demographic filter queries
  @@index([sc, ell, term])
  @@index([sc, specialEd, term])
  @@index([sc, ard, term])
  @@index([sc, gender, term])
  // Index for course-based queries
  @@index([sc, term, courseTitle])
  // Index for department-based queries
  @@index([sc, term, departmentCode])
}

// Optional: Create a view or calculated table for aggregated grade distributions
// model TeacherGradeSummary {
//   id            String   @id @default(cuid())
//   sc            Int
//   tn            String
//   teacherName   String
//   department    String
//   courseTitle   String?
//   courseNumber  String?
//   // period        String?
//   term          String
//   schoolYear    String
//   aCount        Int
//   bCount        Int
//   cCount        Int
//   dCount        Int
//   fCount        Int
//   otherCount    Int
//   totalGrades   Int
//   aPercent      Float
//   bPercent      Float
//   cPercent      Float
//   dPercent      Float
//   fPercent      Float
//   otherPercent  Float
  
//   createdAt     DateTime @default(now())
//   updatedAt     DateTime @updatedAt
  
//   @@index([sc, tn, term])
//   @@index([schoolYear, sc])
// }

enum ROLE {
  USER
  ADMIN
  SUPERADMIN
  HR
  TEACHER
  SITEADMIN
  STAFF
  BUSINESS
  IT
  DISCIPLINE
  SECONDARYTEACHER
  ELEMENTARYTEACHER
  ASSESSMENT
  GRADEDISTRIBUTION
  DIRECTOR
  PRINCIPAL
  COUNSELOR
  NURSE
  LIBRARIAN
  INTERVENTIONS
  IEPUPLOAD
  SPED
  AIQUERY
  QUERYEDITOR
}

enum CHARTTYPE {
  BAR
  LINE
  AREA
  SCATTER
  BUBBLE
  PIE
  DONUT
}

// AI Query Builder Fragment Models
model AIFragment {
  id           String              @id @default(cuid())
  fragmentId   String              @unique // e.g., "students_base", "school_jefferson"
  name         String              // Display name
  description  String              @db.Text
  snippet      String              @db.Text // SQL snippet
  type         FragmentType        // base, filter, join, aggregation, order, column
  categoryId   String
  subcategory  String
  tables       String              @default("[]") // JSON array of table names
  dependencies String              @default("[]") // JSON array of fragment IDs this depends on
  conflicts    String              @default("[]") // JSON array of fragment IDs this conflicts with
  parameters   String              @default("[]") // JSON array of parameter definitions
  outputColumns String             @default("[]") // JSON array of output column names
  tags         String              @default("[]") // JSON array of search tags
  isActive     Boolean             @default(true)
  sortOrder    Int                 @default(0)
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt
  category     AIFragmentCategory  @relation(fields: [categoryId], references: [id])

  @@index([categoryId])
  @@index([type])
  @@index([isActive])
}

model AIFragmentCategory {
  id          String       @id @default(cuid())
  name        String       @unique // e.g., "base_queries", "school_filters"
  displayName String       // e.g., "Base Queries", "School Filters"
  description String?      @db.Text
  sortOrder   Int          @default(0)
  isActive    Boolean      @default(true)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  fragments   AIFragment[]

  @@index([isActive]) // For filtering active categories
}

enum FragmentType {
  base
  filter
  join
  aggregation
  order
  column
}

// CTE (Common Table Expression) queries for AI Query Builder
// These are reusable WITH clauses that can be joined to main queries
model AICteQuery {
  id            String   @id @default(cuid())
  cteId         String   @unique // e.g., "sped_students", "ell_current"
  name          String   // Display name e.g., "Special Education Students"
  description   String   @db.Text // English description of what this CTE returns
  cteSql        String   @db.Text // The actual CTE SQL (WITH clause content)
  joinColumn    String   // Column to join on, e.g., "ID" (student ID)
  outputColumns String   @db.Text // JSON array of column definitions with names and descriptions
  tables        String   @default("[]") // JSON array of Aeries tables used
  tags          String   @default("[]") // JSON array for search/categorization
  isActive      Boolean  @default(true)
  sortOrder     Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([isActive])
}

// Column metadata for documenting Aeries tables
model AeriesColumnMeta {
  id           String   @id @default(cuid())
  tableName    String   // e.g., "STU", "CSE", "PGM"
  columnName   String   // e.g., "SC", "GR", "SP"
  displayName  String   // e.g., "School Code", "Grade", "Special Ed Flag"
  description  String?  @db.Text // Longer description
  dataType     String?  // e.g., "INT", "VARCHAR", "DATE"
  exampleValues String? // e.g., "Y, N" or "2, 3, 4 (school codes)"
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([tableName, columnName])
  @@index([tableName])
}

// Application-wide settings (key-value store)
model AppSetting {
  key       String   @id // e.g., "defaultDbYear", "maintenanceMode"
  value     String   // JSON-encoded value
  label     String?  // Human-readable label for admin UI
  updatedAt DateTime @updatedAt
  updatedBy String?  // User ID who last updated
}
